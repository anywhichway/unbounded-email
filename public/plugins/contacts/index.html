<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Unbounded: Contacts</title>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
        <link rel="stylesheet" href="../index.css">
        <link rel="stylesheet" href="./index.css">
        <!--script src="../../assets/js/lightview-iframe.js"></script-->
        <script src="../../assets/js/lightview.js"></script>
        <script>
            const lightview = Lightview("browser");
            const {render, state, navigate} = lightview;
        </script>
        <!--script src="./index.js"></script-->
        <script src="./contact.js"></script>
        <script src="./contacts.js"></script>
        <script src="../folder-item.js"></script>
    </head>
    <body>
         <script type="module" id="init">
            const {user, ui} = await lightview.import("../", { publish: true, subscribe: true});
            
            const getAccountIconClass = (accountEmail) => {
                const account = user.accounts[accountEmail];
                const accountType = account?.type;
                return ui.accountIcons?.[accountType] || ui.accountIcons?.default || 'fas fa-envelope';
            };
            
            // Get user accounts from user structure
            const userAccounts = user.accounts || {};

            // Get unique tags from contacts (computed dynamically)
            const tagIcons = ui.tagIcons || {};
            
            // Function to get all contacts as references (no flattening or copying)
            // This returns original contact objects from user.accounts to maintain reactivity
            function getAllContacts(user) {
                // flatMap is used here to flatten the nested structure:
                // user.accounts is an object with account emails as keys, each containing a contacts array
                // We need to flatten all contacts into a single array for UI rendering and filtering
                // But we return REFERENCES to the original objects, not copies, to preserve reactivity
                // Modified to include accountEmail for accurate filtering
                return Object.entries(user.accounts).flatMap(([accountEmail, account]) => 
                    (account.contacts || []).map(contact => ({ contact, accountEmail }))
                );
            }

            // Function to compute filtered contacts reactively (no copies)
            function updateFilteredContacts(user) {
                const allContacts = getAllContacts(user);
                appState.filteredContacts = allContacts.filter(({ contact, accountEmail }) => {
                    // First filter by account if one is selected
                    if (appState.currentAccount && accountEmail !== appState.currentAccount) {
                        return false;
                    }
                    
                    // Then apply additional filters based on current selection
                    if (appState.currentTag) {
                        return contact.tags && contact.tags.includes(appState.currentTag);
                    } else if (appState.currentFolder) {
                        const lowerCaseFolder = appState.currentFolder.toLowerCase();
                        switch (lowerCaseFolder) {
                            case 'starred':
                                return contact.starred;
                            case 'frequently contacted':
                                return contact.frequentlyContacted;
                            case 'scheduled':
                                return contact.scheduled;
                            default:
                                return true;
                        }
                    }
                    
                    return true;
                }).map(({ contact }) => contact); // Extract just the contact for appState.filteredContacts
            }

            const getContactsCount = ({ folder, accountEmail, tagName, appState }) => {
                let count = 0;
                const getAllContacts = () => Object.values(appState.user.accounts).flatMap(account => account.contacts || []);
                
                if (accountEmail) {
                    const account = appState.user.accounts[accountEmail];
                    count = account ? (account.contacts || []).length : 0;
                } else if (tagName) {
                    let contactsToCheck = appState.currentAccount ? (appState.user.accounts[appState.currentAccount]?.contacts || []) : getAllContacts();
                    count = contactsToCheck.filter(c => c.tags && c.tags.includes(tagName)).length;
                } else if (folder.name === "All Contacts") {
                    count = getAllContacts().length;
                } else if (folder.name === "Categories") {
                    let contactsToCheck = appState.currentAccount ? (appState.user.accounts[appState.currentAccount]?.contacts || []) : getAllContacts();
                    const uniqueTags = new Set(contactsToCheck.flatMap(c => c.tags || []));
                    count = uniqueTags.size;
                } else if (folder.name === "Starred") {
                    let contactsToCheck = appState.currentAccount ? (appState.user.accounts[appState.currentAccount]?.contacts || []) : getAllContacts();
                    count = contactsToCheck.filter(c => c.starred).length;
                } else if (folder.name === "Frequently Contacted") {
                    let contactsToCheck = appState.currentAccount ? (appState.user.accounts[appState.currentAccount]?.contacts || []) : getAllContacts();
                    count = contactsToCheck.filter(c => c.frequentlyContacted).length;
                } else if (folder.name === "Scheduled") {
                    let contactsToCheck = appState.currentAccount ? (appState.user.accounts[appState.currentAccount]?.contacts || []) : getAllContacts();
                    count = contactsToCheck.filter(c => c.scheduled).length;
                }
                return count;
            };

            // Reactive state for filtering and UI
            const appState = state({
                tagIcons: tagIcons,
                user: user,
                currentAccount: null,
                currentTag: null,
                currentFolder: null,
                selectedFolderId: 'folder-All Contacts',
                editingContact: null,
                filteredContacts: [], // Will be computed from user.accounts (references, no copies)
                getCount: getContactsCount,
                getAccountIconClass,
                selectFolder(folderType, value) {
                    if (folderType === 'account') {
                        appState.currentAccount = value;
                        appState.currentTag = null;
                        appState.currentFolder = null;
                        appState.selectedFolderId = value ? `account-${value.replace('@', '-at-')}` : 'folder-All Contacts';
                    } else if (folderType === 'tag') {
                        appState.currentTag = value;
                        appState.currentFolder = null;
                        appState.selectedFolderId = `category-${value}`;
                    } else if (folderType === 'folder') {
                        appState.currentFolder = value;
                        appState.currentTag = null;
                        if (value === 'All Contacts') {
                            appState.currentAccount = null;
                        }
                        appState.selectedFolderId = `folder-${value}`;
                    }
                    // Update filtered contacts after selection change
                    updateFilteredContacts(appState.user);
                }
            });
            appState.user.tagIcons = JSON.parse(JSON.stringify(tagIcons)); // Ensure reactivity by breaking references
            appState.user.testChange = (user.testChange || 0) + 1; // Dummy property to trigger reactivity

            // Initial setup - compute filtered contacts
            updateFilteredContacts(user);

            document.getElementById("init").replaceWith(await Contacts(appState))
        </script>
    </body>
</html>
